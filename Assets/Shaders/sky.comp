#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;

// Push constants
layout(push_constant) uniform constants {
    vec4 data1;// data1.xyz = background color, data1.w = star threshold
    vec4 data2;
    vec4 data3;
    vec4 data4;
    vec3 cameraPosition;
    float padding;
    mat4 cameraRotation;// Full view matrix (rotation only)
} PushConstants;

// === Simple hash-based noise in [0,1] ===
float Noise2d(in vec2 x) {
    float xhash = cos(x.x * 37.0);
    float yhash = cos(x.y * 57.0);
    return fract(415.92653 * (xhash + yhash));
}

// === Thresholded star generation ===
float NoisyStarField(in vec2 samplePos, float threshold) {
    float val = Noise2d(samplePos);
    if (val >= threshold)
    return pow((val - threshold) / (1.0 - threshold), 6.0);
    return 0.0;
}

// === Bilinear interpolation between 4 noise samples ===
float StableStarField(in vec2 samplePos, float threshold) {
    vec2 floorPos = floor(samplePos);
    vec2 fractPos = fract(samplePos);

    float v1 = NoisyStarField(floorPos, threshold);
    float v2 = NoisyStarField(floorPos + vec2(0.0, 1.0), threshold);
    float v3 = NoisyStarField(floorPos + vec2(1.0, 0.0), threshold);
    float v4 = NoisyStarField(floorPos + vec2(1.0, 1.0), threshold);

    float interp = mix(mix(v1, v3, fractPos.x), mix(v2, v4, fractPos.x), fractPos.y);
    return interp;
}

// === Main compute shader ===
void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y) return;

    vec2 iResolution = vec2(size);
    vec2 fragCoord = vec2(texelCoord);

    // === Background gradient color ===
    vec3 baseColor = PushConstants.data1.xyz * fragCoord.y / iResolution.y;

    // === Convert screen coord to normalized view ray (NDC) ===
    vec2 uv = fragCoord / iResolution * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;// aspect correction
    vec3 forwardRay = normalize(vec3(uv, -1.0));// camera looks along -Z

    // === Extract pitch-only rotation from cameraRotation matrix ===
    // Assume X is world right; use YZ from view matrix
    vec3 camUp = normalize(vec3(PushConstants.cameraRotation[1].xyz));
    vec3 camForward = normalize(vec3(PushConstants.cameraRotation[2].xyz));
    vec3 camRight = normalize(cross(camUp, camForward));
    mat3 pitchOnly = mat3(camRight, camUp, camForward);

    // Apply only pitch (ignoring yaw)
    vec3 rayDir = normalize(pitchOnly * forwardRay);

    // === Sample stars in world space ===
    vec3 worldSample = PushConstants.cameraPosition + rayDir * 900.0;

    // === Domain warping (rotation + scaling) ===
    vec2 hashPos = worldSample.xz;

    // Scale down to increase spatial frequency
    float starVal = StableStarField(hashPos, PushConstants.data1.w);
    vec3 finalColor = baseColor + vec3(starVal);

    imageStore(image, texelCoord, vec4(finalColor, 1.0));
}
